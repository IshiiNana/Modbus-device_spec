#include <ModbusSlave.h>
#include <time.h>
#include <stdlib.h>

#define SLAVE_ID 1           // The Modbus slave ID, change to the ID you want to use.
#define RS485_CTRL_PIN 8     // Change to the pin the RE/DE pin of the RS485 controller is connected to.
#define SERIAL_BAUDRATE 9600 // Change to the baudrate you want to use for Modbus communication.
#define SERIAL_PORT Serial   // Serial port to use for RS485 communication, change to the port you're using.

// The position in the array determines the address. Position 0 will correspond to Coil, Discrete input or Input register 0.
uint8_t digital_pins[] = {4, 7, 9, 12, LED_BUILTIN}; // Add the pins you want to read as a Discrete input.

uint8_t digital_pins_size = sizeof(digital_pins) / sizeof(digital_pins[0]); // Get the size of the digital_pins array

uint8_t regsize = 30;
uint8_t testbuffer = 0;
uint8_t buffval = 0;
uint8_t num = 0;
int ledState = LOW;
unsigned long ledStarted = 0;
unsigned long ledblink = 0;
unsigned long period = 500;
unsigned long period2 = 1000;

// Modbus object declaration
Modbus slave(SERIAL_PORT, SLAVE_ID, RS485_CTRL_PIN);

void setup()
{
  // Set the defined digital pins to the value stored in EEPROM.
  for (uint16_t i = 0; i < digital_pins_size; i++)
  {
    uint8_t pinMode_setting;

    pinMode(digital_pins[i], OUTPUT);
  }

  // Register functions to call when a certain function code is received.
  slave.cbVector[CB_READ_HOLDING_REGISTERS] = readMemory;
  slave.cbVector[CB_WRITE_HOLDING_REGISTERS] = writeMemory;

  // Set the serial port and slave to the given baudrate.
  SERIAL_PORT.begin(SERIAL_BAUDRATE);
  slave.begin(SERIAL_BAUDRATE);
}

void loop()
{
  slave.poll();
  if (testbuffer == 3) {
    unsigned long ntime = millis();
    if (ntime - ledStarted >= period) {
      ledStarted = ntime;
      if (ledState == LOW) {
        ledState = HIGH;
      } else {
        ledState = LOW;
      }
      digitalWrite(LED_BUILTIN, ledState);
    }
  } /*else {
    digitalWrite(LED_BUILTIN, LOW);
  }*/
  
  if (buffval != 0) {
    unsigned long time_now = millis();
    if (time_now - ledblink >= period2) {
      digitalWrite(LED_BUILTIN, HIGH);
      buffval = 0;
    }
  }
}

// Handle the function code Read Holding Registers (FC=03) and write back the values from the EEPROM (holding registers).
uint8_t readMemory(uint8_t fc, uint16_t address, uint16_t length)
{
  for (int i = 0; i < length; i++)
  {
    // Below 50 is reserved for pinModes, above 50 is free to use.
    if (address + i == 0x18)
    {
      uint8_t value;
      slave.writeRegisterToBuffer(i, num);
      return STATUS_OK;
    } else {
      return STATUS_ILLEGAL_DATA_ADDRESS;
    }
  }
}

// Handle the function codes Write Holding Register(s) (FC=06, FC=16) and write data to the eeprom.
uint8_t writeMemory(uint8_t fc, uint16_t address, uint16_t length)
{
  // Write the received data to EEPROM.
  for (int i = 0; i < length; i++)
  {
    if (address + i <= 50)
    {
      if (address + i < 0x16 || address + i > 0x19 || address + i == 0x18)
      {
        return STATUS_ILLEGAL_DATA_ADDRESS;
      }

      // Read the value from the input buffer.
      uint8_t value = slave.readRegisterFromBuffer(i);

      if (address + i == 0x16) {
        testbuffer = value;
        if (value == 1) {
          digitalWrite(digital_pins[0], HIGH);
          digitalWrite(digital_pins[1], LOW);
        }
        if (value == 2) {
          digitalWrite(digital_pins[0], LOW);
          digitalWrite(digital_pins[1], HIGH);
        }
        if (value == 3) {
          digitalWrite(digital_pins[0], LOW);
        }
      }
      if (address + i == 0x17) {
        if (value == 1) {
          digitalWrite(digital_pins[2], LOW);
          digitalWrite(LED_BUILTIN, LOW);
          buffval = value;
          ledblink = millis();
        }
        if (value == 2) {
          digitalWrite(digital_pins[2], HIGH);
          digitalWrite(LED_BUILTIN, LOW);
          buffval = value;
          ledblink = millis();
        }
      }
      if (address + i == 0x19) {
        if (value == 1) {
          func();
        }
      }
    }
  }

  return STATUS_OK;
}

void func() {
  num = num + 1;
}